# 失业日记
2020/07/15 公司解散 留守在家 发愤图强 开始温习书本 为下一个旅程做更好的准备

---
。。。过了半个月
###2020年07月29日23:30:56

今天折腾了一晚，总算有了点收获。
之前真的觉得自己记忆力衰退厉害，学什么看什么都看不入脑。
直到女朋友点醒了我，是不是学的东西没理解，所以过目就忘。

然后今晚来个各个击破，把之前自己不理解的都慢慢击破。

1，编程语言的垃圾回收机制：
   常见的回收方式：
   一，引用计算法: 遍历所有对象，有引用的+1，没引用的-1，直到对象引用数为0的时候判定为垃圾进行回收。缺点：对相互引用
   但已失效的对象无法回收。优点：回收比较及时。PHP在用。
   二，标记-清理法：初始化所有对象为0，引用对象的时候更新标记为1，周期结束的时候回收所有标记为0的对象。缺点：内存开销
   大，运行的时候需要暂停对象运行（随意变更标记会导致回收对象出错)
   三，三色标记法：这个是根据标记-清理法的一种优化，新增三个集合，把所有对象都标记为白色球放置在第一集合，遍历对象把有
   引用的对象标记为灰色，然后遍历其子对象标记为灰色，此对象标记为黑色，此步骤循环到底，结束后回收第一集合剩余的标记为
   白色球的没有被引用的对象。Golang在用。
   四，分代收集法：此种算法是基于一种生活规则：一般的对象的生命周期都很短。因此将不同周期的对象按时间分3代，初始化将某
   小部分对象标记为0代，当内存到达某个阈值的时候，回收0代对象，剩余部分小对象到达1代，当内存到达更大一个阈值的时候触发
   回收1代，2代同理。Java在用。

2，redis常见问题和考点：
    五种数据结构：string,list,hash,set,hset.
    string:最常见的k-v存储结构
    list:形容为k-vs的结构吧，一个双向链表，可以做队列或者做堆栈都可以，用不同方法实现先进先出或者先进后出。
    hash:散列表结构，k-v，v是比较形象的结构，比喻存储userInfo,可以把用户，头像，性别，比较直观的存储进去。
    set:集合，一个自动去重的无序集合表。
    zset:有序集合，类似set,zset是一个自动去重集合，但是是带有自动排序的。
    
    常见缓存问题：
    缓存雪崩：形容一个时间点，所有的缓存都没了导致所有连接请求全部到了关系数据库。方法1，使用加锁或者消息队列控制连接
    流量避免同一个时间太多连接请求到数据库。方法2，设置redis缓存过期时间加个随机因子，防止一个时间点缓存全过期的现象。
    
    缓存穿透：形容某个请求在缓存层没有数据，在关系数据库也没有数据，导致这个请求每次都是直接请求到数据库。方法1，最常
    用的接近方法就是布隆过滤器，一个专门为了验证某个元素是否包含在集合里的算法。举个例子说明布隆过滤器，初始化一个bigmap,
    假设数据库某表存在id=1,2,3，那么这些字段就在bigmap里面经过3次hash函数得到三个key，并把这个key的值设置为1。请
    求遇到参数id=1，那么同样3次hash函数得到三个key的值都为1的话，那么id=1这个值很可能存在，那么就直接去查表，如果
    请求id=4,那么经过3次hash函数得到三个key的值，如果其中不全为1的话，那么id=4这个值肯定不存在直接返回数据不存在。
    优点：空间和时间都很好，缺点：存在误判，删除bigmap值困难。方法2，因为是查询为null导致每次请求直接到数据库，那么
    设置null值为缓存，过期时间比较短（比喻60s),就可以避免短时所有请求击穿缓存，缺点：容易导致redis空值多，占内存。
    
    redis过期时间删除机制：
    redis可以设置过期时间，和设定删除机制，
    删除机制分为三种：
    1，过期立刻删除。占用CPU
    2,被动删除，请求触发的时候先判断有没过期，过期删除。会导致冷数据特别多，死沉redis占用内存。曾经踩锅。
    3，定时删除，综合1，2缺点比较适合的一种方式。
   

3，TCP中的三次握手：
    TCP三次握手，HTTP/1.1里面keep-alive是默认开启的，就是一个tcp里面可以请求多次http链接，Tcp是一种可靠的传输
    协议，其核心思想是保证数据的可靠性的同时提高传输的效率，刚刚好就是三次握手的前提。三次握手：客户端A主动发送第一次
    同步信号SYN+机器码到B服务器，B服务器记录同步SYN，然后发送SYN+机器码给A客户端，并且等待A客户端确认，A客户端收到
    信号后，发送SYN+机器码给B服务器，B服务器记录后，开始传输数据。
    为什么不是二次握手，而是三次握手，因为网络传输存在延迟或者掉失的可能， 如果只是简单1，2确认，而没有最后一步客户端
    发送确认信号到服务端，会导致数据没法保证准确。

---